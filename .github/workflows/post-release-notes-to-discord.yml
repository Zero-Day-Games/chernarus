name: Post release notes to Discord

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: "Optional: post notes for this tag instead of the latest"
        type: string
        required: false

concurrency:
  group: discord-release-notes
  cancel-in-progress: false

jobs:
  notify:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      WEBHOOK_URL: ${{ secrets.DISCORD_RELEASE_WEBHOOK_URL }}
      ROLE_ID: ${{ secrets.DISCORD_ROLE_ID }} # optional: role ID to mention
      THREAD_ID: ${{ secrets.DISCORD_WEBHOOK_THREAD_ID }} # optional: post into specific thread

    steps:
      - name: Post release notes to Discord
        uses: actions/github-script@v7
        env:
          WEBHOOK_URL: ${{ env.WEBHOOK_URL }}
          ROLE_ID: ${{ env.ROLE_ID }}
          THREAD_ID: ${{ env.THREAD_ID }}
        with:
          script: |
            const { owner, repo } = context.repo;

            if (!process.env.WEBHOOK_URL) {
              core.setFailed("Missing secret: DISCORD_RELEASE_WEBHOOK_URL");
              return;
            }

            // --- 1) Determine which release to post ---
            let rel;
            if (context.eventName === "release") {
              rel = context.payload.release;
            } else {
              const tag = core.getInput("tag");
              try {
                if (tag) {
                  const { data } = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
                  rel = data;
                } else {
                  const { data } = await github.rest.repos.getLatestRelease({ owner, repo });
                  rel = data;
                }
              } catch (e) {
                core.setFailed(`Unable to resolve release (${e.status || "n/a"}): ${e.message}`);
                return;
              }
            }

            if (!rel) {
              core.setFailed("No release found to post.");
              return;
            }

            // --- 2) Prepare content ---
            const safe = (s) => (s || "")
              .replace(/@everyone/g, '@\u200beveryone')
              .replace(/@here/g, '@\u200bhere');

            // Title: just the tag (fallback to name if needed)
            const titleTag = rel.tag_name || rel.name || "New Release";
            const url = rel.html_url;
            const bodyRaw = rel.body || "";
            const body = safe(bodyRaw.trim());

            // Chunking for Discord limits
            const chunk = (text, size) => {
              if (!text) return [];
              const parts = [];
              let remaining = text;
              while (remaining.length > size) {
                const slice = remaining.slice(0, size);
                const nl = slice.lastIndexOf("\n");
                const cut = nl > 200 ? nl : size;
                parts.push(remaining.slice(0, cut).trimEnd());
                remaining = remaining.slice(cut).replace(/^\n+/, "");
              }
              if (remaining.length) parts.push(remaining);
              return parts;
            };

            const chunks = chunk(body, 3800); // under 4096 embed desc limit
            const mention = process.env.ROLE_ID ? `<@&${process.env.ROLE_ID}>` : "";
            const webhookURL = process.env.THREAD_ID
              ? `${process.env.WEBHOOK_URL}?thread_id=${process.env.THREAD_ID}`
              : process.env.WEBHOOK_URL;

            const send = async (payload) => {
              const res = await fetch(webhookURL, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              });
              if (!res.ok) {
                const txt = await res.text();
                throw new Error(`Discord webhook failed: ${res.status} ${res.statusText} :: ${txt}`);
              }
            };

            // --- 3) First message (embed with title == tag) ---
            const firstEmbed = {
              title: titleTag,           // <-- just "v1.0.3"
              url,
              description: chunks.length ? chunks[0] : "_No release notes provided._",
              color: 0x5865F2,
              timestamp: rel.published_at || new Date().toISOString(),
              footer: { text: `Published by ${rel.author?.login ?? owner}` },
            };

            await send({
              username: "Release Notes",
              content: mention || undefined,
              embeds: [firstEmbed],
              allowed_mentions: mention ? { parse: [], roles: [process.env.ROLE_ID] } : { parse: [] },
            });

            // --- 4) Overflow chunks (if any) ---
            for (let i = 1; i < chunks.length; i++) {
              await send({
                username: "Release Notes",
                embeds: [{ description: chunks[i], color: 0x5865F2 }],
                allowed_mentions: { parse: [] },
              });
            }

            core.info(`Posted ${titleTag} to Discord in ${chunks.length || 1} message(s).`)
