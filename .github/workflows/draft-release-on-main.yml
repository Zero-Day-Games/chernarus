name: Draft Release on main updates

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: draft-release-on-main
  cancel-in-progress: false

jobs:
  draft_release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Create/Update rolling draft release with commit notes
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;

            // ---------- helpers ----------
            const parseVer = (s) => {
              if (!s) return null;
              const m = s.trim().replace(/^v/i,'').match(/^(\d+)\.(\d+)\.(\d+)$/);
              if (!m) return null;
              return { major:+m[1], minor:+m[2], patch:+m[3], raw:`${+m[1]}.${+m[2]}.${+m[3]}` };
            };
            const cmp = (a,b) => a.major-b.major || a.minor-b.minor || a.patch-b.patch;
            const incPatch = (v) => ({ major:v.major, minor:v.minor, patch:v.patch+1 });

            // ---------- 1) Collect releases & tags ----------
            const releases = await github.paginate(github.rest.repos.listReleases, { owner, repo, per_page: 100 });
            const tags = await github.paginate(github.rest.repos.listTags, { owner, repo, per_page: 100 });

            // Highest existing semver across releases & tags (for when we need to CREATE a new draft)
            const allVers = [];
            for (const r of releases) { const v = parseVer(r.tag_name); if (v) allVers.push(v); }
            for (const t of tags)     { const v = parseVer(t.name);     if (v) allVers.push(v); }

            let baseNext = { major:1, minor:0, patch:0 };
            if (allVers.length) {
              allVers.sort(cmp);
              baseNext = incPatch(allVers[allVers.length - 1]); // bump only when creating new draft
            }
            const computedNextTag = `v${baseNext.major}.${baseNext.minor}.${baseNext.patch}`;

            // ---------- 2) Choose base for notes ONLY from real git tags ----------
            const tagVers = [];
            for (const t of tags) { const v = parseVer(t.name); if (v) tagVers.push({ v, name: t.name }); }
            tagVers.sort((a,b) => cmp(a.v,b.v));
            const lastRealTag = tagVers.length ? tagVers[tagVers.length - 1].name : null;

            // ---------- 3) Build release body (commit subjects) ----------
            let lines = [];
            let header = '';
            try {
              if (lastRealTag) {
                const cmpRes = await github.rest.repos.compareCommitsWithBasehead({
                  owner, repo, basehead: `${lastRealTag}...main`,
                });
                lines = (cmpRes.data.commits || []).map(c =>
                  `- ${c.commit.message.split('\n')[0]} (${c.sha.slice(0,7)})`
                );
                header = `Changes since ${lastRealTag}:`;
              } else {
                // No prior real tag; list latest commits on main
                const commits = await github.paginate(github.rest.repos.listCommits, {
                  owner, repo, sha: 'main', per_page: 100
                });
                lines = commits.map(c =>
                  `- ${c.commit.message.split('\n')[0]} (${c.sha.slice(0,7)})`
                );
                header = `Changes on main:`;
              }
            } catch (e) {
              core.warning(`Compare failed (${e.status || 'n/a'}) — falling back to recent commits.`);
              const commits = await github.paginate(github.rest.repos.listCommits, {
                owner, repo, sha: 'main', per_page: 100
              });
              lines = commits.map(c =>
                `- ${c.commit.message.split('\n')[0]} (${c.sha.slice(0,7)})`
              );
              header = `Changes on main:`;
            }

            const body = `${header}\n\n${lines.join('\n') || '- No new commits found.'}`;

            // ---------- 4) Keep a single rolling draft ----------
            const drafts = releases.filter(r => r.draft)
              .sort((a,b) => new Date(b.created_at) - new Date(a.created_at));
            const existingDraft = drafts[0] || null;

            if (existingDraft) {
              // ✅ Do NOT bump or change the tag/name while it's a draft.
              await github.rest.repos.updateRelease({
                owner, repo,
                release_id: existingDraft.id,
                body,
                draft: true,
                prerelease: false,
              });
              core.info(`Updated existing draft (${existingDraft.tag_name || '<no tag set>'}) with ${lines.length} commit(s).`);
            } else {
              // No draft exists → create a NEW draft at the next version
              const { data: created } = await github.rest.repos.createRelease({
                owner, repo,
                tag_name: computedNextTag,
                target_commitish: "main",
                name: computedNextTag,
                body,
                draft: true,
                prerelease: false,
              });
              core.info(`Created new draft ${created.name} (${created.tag_name}) with ${lines.length} commit(s).`);
            }
