name: Draft Release on main updates

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: draft-release-on-main
  cancel-in-progress: false

jobs:
  draft_release:
    runs-on: ubuntu-latest
    permissions:
      contents: write   # needed for releases/tags

    steps:
      - name: Create/Update rolling draft release with commit notes
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;

            // --- helpers ---
            const parseVer = (s) => {
              if (!s) return null;
              const m = s.trim().replace(/^v/i,'').match(/^(\d+)\.(\d+)\.(\d+)$/);
              if (!m) return null;
              return { major:+m[1], minor:+m[2], patch:+m[3], raw:`${+m[1]}.${+m[2]}.${+m[3]}` };
            };
            const cmp = (a,b) => a.major-b.major || a.minor-b.minor || a.patch-b.patch;
            const incPatch = (v) => ({ major:v.major, minor:v.minor, patch:v.patch+1 });

            // --- 1) Gather existing semver tags/releases ---
            const releases = await github.paginate(github.rest.repos.listReleases, { owner, repo, per_page: 100 });
            const tags = await github.paginate(github.rest.repos.listTags, { owner, repo, per_page: 100 });

            let versions = [];
            for (const r of releases) {
              const v = parseVer(r.tag_name); if (v) versions.push(v);
            }
            for (const t of tags) {
              const v = parseVer(t.name); if (v) versions.push(v);
            }

            let baseTag = null; // last tag we compare from
            let nextVer = { major:1, minor:0, patch:0 };

            if (versions.length) {
              versions.sort(cmp);
              const top = versions[versions.length-1];      // highest existing tag/release
              baseTag = `v${top.raw}`;                      // compare from here
              nextVer = incPatch(top);                      // bump patch each push
            }

            const nextTag = `v${nextVer.major}.${nextVer.minor}.${nextVer.patch}`;
            const nextName = nextTag;

            // --- 2) Build release body with commit messages ---
            let lines = [];
            if (baseTag) {
              // commits from last tag to main
              const cmpRes = await github.rest.repos.compareCommitsWithBasehead({
                owner, repo, basehead: `${baseTag}...main`,
              });
              lines = (cmpRes.data.commits || []).map(c =>
                `- ${c.commit.message.split('\\n')[0]} (${c.sha.slice(0,7)})`
              );
            } else {
              // no prior tag; list recent commits on main (up to 100)
              const commits = await github.paginate(github.rest.repos.listCommits, {
                owner, repo, sha: 'main', per_page: 100
              });
              lines = commits.map(c =>
                `- ${c.commit.message.split('\\n')[0]} (${c.sha.slice(0,7)})`
              );
            }

            const header = baseTag
              ? `Changes since ${baseTag}:`
              : `Changes on main:`;
            const body = `${header}\n\n${lines.join('\\n') || '- No new commits found.'}`;

            // --- 3) Maintain a single rolling draft release ---
            const drafts = releases.filter(r => r.draft)
              .sort((a,b) => new Date(b.created_at)-new Date(a.created_at));
            const existingDraft = drafts[0] || null;

            if (existingDraft) {
              await github.rest.repos.updateRelease({
                owner, repo,
                release_id: existingDraft.id,
                tag_name: nextTag,
                target_commitish: "main",
                name: nextName,
                body,
                draft: true,
                prerelease: false,
              });
              core.info(`Updated draft â†’ ${nextTag} with ${lines.length} commit(s).`);
            } else {
              const { data: created } = await github.rest.repos.createRelease({
                owner, repo,
                tag_name: nextTag,
                target_commitish: "main",
                name: nextName,
                body,
                draft: true,
                prerelease: false,
              });
              core.info(`Created draft ${created.name} with ${lines.length} commit(s).`);
            }
